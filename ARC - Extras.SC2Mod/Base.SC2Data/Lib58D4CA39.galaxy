include "TriggerLibs/NativeLib"
include "LibCOMI"
include "LibNHBR"
include "LibUEDC"
include "LibDRAG"

include "Lib58D4CA39_h"

//--------------------------------------------------------------------------------------------------
// Library: Extras
//--------------------------------------------------------------------------------------------------
// External Library Initialization
void lib58D4CA39_InitLibraries () {
    libNtve_InitVariables();
    libCOMI_InitVariables();
    libNHBR_InitVariables();
    libUEDC_InitVariables();
}

// Functions
void lib58D4CA39_gf_AIDiamondback (int lp_owner, unit lp_diamondback, unitgroup lp_nearbyUnits) {
    // Variable Declarations
    point lv_moveTo;
    point lv_moveToA;
    point lv_moveToB;
    unitgroup lv_enemies;

    // Automatic Variable Declarations
    int auto7DF8C020_val;

    // Variable Initialization
    lv_enemies = UnitGroupEmpty();

    // Implementation
    lv_enemies = UnitGroupFilterRegion(UnitGroupFilterPlane(lp_nearbyUnits, c_planeGround, 0), RegionCircle(UnitGetPosition(lp_diamondback), 6.2), 0);
    if ((UnitGroupCount(lv_enemies, c_unitCountAlive) >= 1)) {
        lv_moveTo = PointWithOffsetPolar(UnitGetPosition(lp_diamondback), 5.0, AngleBetweenPoints(UnitGroupCenterOfGroup(lv_enemies), UnitGetPosition(lp_diamondback)));
        if ((PointPathingCost(UnitGetPosition(lp_diamondback), lv_moveTo) >= 1000)) {
            lv_moveToA = PointWithOffsetPolar(UnitGetPosition(lp_diamondback), 5.0, (AngleBetweenPoints(UnitGroupCenterOfGroup(lv_enemies), UnitGetPosition(lp_diamondback)) + 45.0));
            lv_moveToB = PointWithOffsetPolar(UnitGetPosition(lp_diamondback), 5.0, (AngleBetweenPoints(UnitGroupCenterOfGroup(lv_enemies), UnitGetPosition(lp_diamondback)) - 45.0));
            if ((PointPathingCost(UnitGetPosition(lp_diamondback), lv_moveToA) < 1000) && (PointPathingCost(UnitGetPosition(lp_diamondback), lv_moveToB) < 1000)) {
                auto7DF8C020_val = RandomInt(1, 2);
                if (auto7DF8C020_val == 1) {
                    lv_moveTo = lv_moveToA;
                }
                else if (auto7DF8C020_val == 2) {
                    lv_moveTo = lv_moveToB;
                }
                else {
                }
            }
            else {
                if ((PointPathingCost(UnitGetPosition(lp_diamondback), lv_moveToA) < 1000)) {
                    lv_moveTo = lv_moveToA;
                }
                else {
                    if ((PointPathingCost(UnitGetPosition(lp_diamondback), lv_moveToB) < 1000)) {
                        lv_moveTo = lv_moveToB;
                    }
                    else {
                        lv_moveTo = null;
                    }
                }
            }
        }

        if ((lv_moveTo != null)) {
            UnitIssueOrder(lp_diamondback, OrderTargetingPoint(AbilityCommand("move", 0), lv_moveTo), c_orderQueueReplace);
        }

        Wait(1.5, c_timeAI);
        AISetUnitScriptControlled(lp_diamondback, false);
    }

}

void lib58D4CA39_gf_AIHavoc (int lp_player, unit lp_havoc, unitgroup lp_scan_group) {
    // Automatic Variable Declarations
    // Implementation
        int player = lp_player;
        unit havoc = lp_havoc;
        unitgroup scan_group = lp_scan_group;
        const fixed c_forceFieldMeleeRange      = 1.5;
        const fixed c_forceFieldRadius          = 2.0;
        const fixed c_forceFieldRange           = 8.0;
        const fixed c_forceFieldFriendRange     = 9.0;
        order force_field_order = AICreateOrder(player, "ForceFieldMonitor", 0);
        point havoc_position = UnitGetPosition(havoc);
        aifilter filter_ai;
        unitgroup ground_enemies;
        unitgroup melee_enemy_group;
        unitgroup range_enemy_group;
        unitfilter filter_unit;
        unitgroup friendly_group;
        int friendly_count = 0;
        unit friendly_unit;
        int friendly_vitality = 0;
        bool friendly_has_melee = false;
        int enemy_count = 0;
        unit enemy_unit;
        point enemy_position;
        fixed enemy_distance;
        int best_priority = 0;
        point best_enemy_position = null;
        point best_friend_position = null;
        unit best_target_unit = null;
        point force_field_target = null;
        // Do not proceed if the order is invalid for some reason
        if (!UnitOrderIsValid(havoc, force_field_order)) {
            return;
        }
        // Filter out air units
        filter_ai = AIFilter(player);
        AISetFilterPlane(filter_ai, c_planeGround);
        AISetFilterCanAttackAlly(filter_ai, c_groundAlliesNearby, false);
        ground_enemies = AIGetFilterGroup(filter_ai, scan_group);
        // Is there a threat in the area
        enemy_count = UnitGroupCount(ground_enemies, c_unitCountAll);
        if (enemy_count <= 0) {
            return;
        }
        // Get a list of only melee enemies
        filter_ai = AIFilter(player);
        AISetFilterMelee(filter_ai, c_onlyMelee);
        melee_enemy_group = AIGetFilterGroup(filter_ai, ground_enemies);
        // Setup a friendly filter
        filter_unit = UnitFilter(0,0,0,0);
        UnitFilterSetState(filter_unit, c_targetFilterUncommandable,             c_unitFilterExcluded);
        UnitFilterSetState(filter_unit, c_targetFilterWorker,                    c_unitFilterExcluded);
        UnitFilterSetState(filter_unit, c_targetFilterUnderConstruction,         c_unitFilterExcluded);
        UnitFilterSetState(filter_unit, c_targetFilterStructure,                 c_unitFilterExcluded);
        // *** Scan the area for the following, set priority unit when found *** (highest first)
        // Priority 4: Melee enemy close to me
        // Priority 3: A friendly unit close to death, who has a melee enemy close by
        // Priority 2: A friendly ranged unit who has a melee enemy close by
        // Priority 1: Large clump of enemies (if we have extra energy)
        //
        // First check only melee enemies
        enemy_count = UnitGroupCount(melee_enemy_group, c_unitCountAll);
        while (enemy_count > 0) {
            enemy_unit = UnitGroupUnit(melee_enemy_group, enemy_count);
            enemy_count = enemy_count - 1;
            enemy_position = UnitGetPosition(enemy_unit);
            enemy_distance = DistanceBetweenPoints(havoc_position, enemy_position);
            if (enemy_distance <= c_forceFieldMeleeRange) {
                best_target_unit = enemy_unit;
                best_enemy_position = enemy_position;
                best_friend_position = havoc_position;
                best_priority = 4;
                break;
            }
            friendly_group = UnitGroupAlliance(player, c_unitAllianceAlly, RegionCircle(enemy_position, c_forceFieldMeleeRange), filter_unit, c_noMaxCount);
            friendly_has_melee = AIUnitGroupHasMelee(friendly_group);
            friendly_count = UnitGroupCount(friendly_group, c_unitCountAll);
            while (friendly_count > 0) {
                friendly_unit = UnitGroupUnit(friendly_group, friendly_count);
                friendly_count = friendly_count - 1;
                friendly_vitality = UnitGetPropertyInt(friendly_unit, c_unitPropVitalityPercent, c_unitPropCurrent);
                if (friendly_vitality < 20) {
                    best_target_unit = enemy_unit;
                    best_enemy_position = enemy_position;
                    best_friend_position = UnitGetPosition(friendly_unit);
                    best_priority = 3;
                    break;
                }
                else if (!friendly_has_melee) {
                    best_target_unit = enemy_unit;
                    best_enemy_position = enemy_position;
                    best_friend_position = UnitGetPosition(friendly_unit);
                    best_priority = 2;
                }
            }
        }
        if (best_priority == 0) {
            // no dangerous melee units found, split large ranged groups
            // filter only ranged units
            filter_ai = AIFilter(player);
            AISetFilterMelee(filter_ai, c_onlyRanged);
            range_enemy_group = AIGetFilterGroup(filter_ai, ground_enemies);
            // see if there is a large group nearby to split
            force_field_target = AIBestTargetPoint(
                range_enemy_group,
                6, // min hits
                1, // damage base
                6.0, // min score
                c_forceFieldRadius,
                UnitGetPosition(havoc),
                c_forceFieldRange,
                c_unitAttributeNone
            );
            if (force_field_target == null) {
                return;
            }
        }
        else {
            // get a point a bit in front of the enemy to shove him away
            enemy_distance = DistanceBetweenPoints(best_friend_position, best_enemy_position);
            if (enemy_distance < 2.0) {
                force_field_target = PointAlongLine(best_friend_position, best_enemy_position, enemy_distance/2.0);
            } else {
                force_field_target = PointAlongLine(best_friend_position, best_enemy_position, enemy_distance - 1.0);
            }
        }
        OrderSetTargetPoint(force_field_order, force_field_target);
        if (!UnitOrderIsValid(havoc, force_field_order)) {
            return;
        }
        if (UnitGroupCount(AIFindUnits(player, "ForceField", force_field_target, 0.5, 1), c_unitCountAlive) > 0) {
            return;
        }
        AICast(havoc, force_field_order, c_noMarker, c_castHold);
}

void lib58D4CA39_gf_AIAscendant (int lp_player, unit lp_ascendant, unitgroup lp_scan_group) {
    // Automatic Variable Declarations
    // Implementation

        int player = lp_player;
        unit ascendant = lp_ascendant;
        unitgroup scan_group = lp_scan_group;
        const int PsiOrbCooldownId = 0;
        unitgroup enemies = UnitGroupFilterAlliance(scan_group, player, c_unitAllianceEnemy, 1);
        if (UnitGroupCount(enemies, c_unitCountAlive) == 0) {
            return;
        }
        if (AITactCooldownAllow(ascendant, PsiOrbCooldownId)) {
            // Cast Psi Orb
            if (AIEvalTacticalData(ascendant, "AscendantPsiOrb")) {
                AISetCooldown(ascendant, PsiOrbCooldownId, 5.0);
                return;
            }
        }
        //  If we already have a psi orb order, ignore any new orders since psi orb is more important.
        //  If we already have a Mind Blast order, ignore any new Mind Blast orders.
        if (UnitOrderHasAbil(ascendant, "VoidHighTemplarMindBlast") || UnitOrderHasAbil(ascendant, "VoidHighTemplarPsiOrb")) {
            return;
        }
        // Cast Mind Blast
        AIEvalTacticalData(ascendant, "AscendantMindBlast");
}

// Triggers
//--------------------------------------------------------------------------------------------------
// Trigger: Initialization
//--------------------------------------------------------------------------------------------------
bool lib58D4CA39_gt_Initialization_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Actions
    if (!runActions) {
        return true;
    }

    TriggerExecute(libNHBR_gt_InitializeNetworkHybridRace, true, false);
    TriggerExecute(libDRAG_gt_InitializeDragonsRace, true, false);
    TriggerExecute(libUEDC_gt_InitializeUEDRace, true, false);
    TriggerExecute(lib58D4CA39_gt_InitializeKeironRace, true, false);
    return true;
}

//--------------------------------------------------------------------------------------------------
void lib58D4CA39_gt_Initialization_Init () {
    lib58D4CA39_gt_Initialization = TriggerCreate("lib58D4CA39_gt_Initialization_Func");
    TriggerAddEventGeneric(lib58D4CA39_gt_Initialization, libCOMI_gv_cOOP_MISSION_STARTED);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Initialize Keiron Race
//--------------------------------------------------------------------------------------------------
bool lib58D4CA39_gt_InitializeKeironRace_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Actions
    if (!runActions) {
        return true;
    }

    TriggerEnable(lib58D4CA39_gt_KeironUpgrades, true);
    TriggerEnable(lib58D4CA39_gt_KeironAutoAperture, true);
    TriggerEnable(lib58D4CA39_gt_AegisDied, true);
    TriggerEnable(lib58D4CA39_gt_AegisCreated, true);
    return true;
}

//--------------------------------------------------------------------------------------------------
void lib58D4CA39_gt_InitializeKeironRace_Init () {
    lib58D4CA39_gt_InitializeKeironRace = TriggerCreate("lib58D4CA39_gt_InitializeKeironRace_Func");
}

//--------------------------------------------------------------------------------------------------
// Trigger: KeironUpgrades
//--------------------------------------------------------------------------------------------------
bool lib58D4CA39_gt_KeironUpgrades_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    string auto9AD48FC2_val;

    // Actions
    if (!runActions) {
        return true;
    }

    auto9AD48FC2_val = EventUpgradeName();
    if (auto9AD48FC2_val == "UpgradeKeironLevel01") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel02") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel03") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel04") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel05") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel06") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel07") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel08") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel09") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel10") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel11") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel12") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel13") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel14") {
    }
    else if (auto9AD48FC2_val == "UpgradeKeironLevel15") {
    }
    else {
    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void lib58D4CA39_gt_KeironUpgrades_Init () {
    lib58D4CA39_gt_KeironUpgrades = TriggerCreate("lib58D4CA39_gt_KeironUpgrades_Func");
    TriggerEnable(lib58D4CA39_gt_KeironUpgrades, false);
    TriggerAddEventUpgradeLevelChanged(lib58D4CA39_gt_KeironUpgrades, c_playerAny);
}

//--------------------------------------------------------------------------------------------------
// Trigger: KeironAutoAperture
//--------------------------------------------------------------------------------------------------
bool lib58D4CA39_gt_KeironAutoAperture_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_apertureUnit;
    unitgroup lv_apertures;
    int lv_neededEnergy;
    unit lv_bestAperture;
    fixed lv_bestDistance;
    fixed lv_newDistance;
    string lv_weapon;
    string lv_effect;
    fixed lv_damage;

    // Automatic Variable Declarations
    unitgroup auto60880210_g;
    int auto60880210_u;

    // Variable Initialization
    lv_apertures = UnitGroup("Aperture", UnitGetOwner(EventUnit()), RegionCircle(UnitGetPosition(EventUnit()), 500.0), UnitFilter(0, 0, (1 << c_targetFilterMissile), (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32))), 0);
    lv_neededEnergy = (CatalogFieldValueGetAsInt(c_gameCatalogUnit, UnitGetType(EventUnit()), "CargoSize", c_playerAny) * 10);
    lv_bestDistance = 999.0;
    lv_effect = EventUnitDamageEffect();
    lv_damage = EventUnitDamageAmount();

    // Conditions
    if (testConds) {
        if (!((UnitGroupCount(lv_apertures, c_unitCountAlive) > 0))) {
            return false;
        }

        if (!(((UnitGetPropertyInt(EventUnit(), c_unitPropLife, c_unitPropCurrent) + UnitGetPropertyInt(EventUnit(), c_unitPropShields, c_unitPropCurrent)) < FixedToInt(lv_damage)))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    auto60880210_g = lv_apertures;
    auto60880210_u = UnitGroupCount(auto60880210_g, c_unitCountAll);
    for (;; auto60880210_u -= 1) {
        lv_apertureUnit = UnitGroupUnitFromEnd(auto60880210_g, auto60880210_u);
        if (lv_apertureUnit == null) { break; }
        if ((lv_apertureUnit != EventUnit()) && (UnitCheckAbilCmdState(lv_apertureUnit, AbilityCommand("AutoKeyhole", 0), c_cmdStateIsAutoCast) == true) && (UnitGetPropertyFixed(lv_apertureUnit, c_unitPropEnergy, c_unitPropCurrent) >= lv_neededEnergy)) {
            lv_newDistance = DistanceBetweenPoints(UnitGetPosition(EventUnit()), UnitGetPosition(lv_apertureUnit));
            if ((lv_newDistance < lv_bestDistance)) {
                lv_bestDistance = lv_newDistance;
                lv_bestAperture = lv_apertureUnit;
            }

        }

    }
    if ((lv_bestAperture != null)) {
        UnitIssueOrder(lv_bestAperture, OrderTargetingUnit(AbilityCommand("AutoKeyhole", 0), EventUnit()), c_orderQueueAddToFront);
    }

    return true;
}

//--------------------------------------------------------------------------------------------------
void lib58D4CA39_gt_KeironAutoAperture_Init () {
    lib58D4CA39_gt_KeironAutoAperture = TriggerCreate("lib58D4CA39_gt_KeironAutoAperture_Func");
    TriggerEnable(lib58D4CA39_gt_KeironAutoAperture, false);
    TriggerAddEventUnitDamaged(lib58D4CA39_gt_KeironAutoAperture, null, c_unitDamageTypeAny, c_unitDamageNonFatal, null);
}

//--------------------------------------------------------------------------------------------------
// Trigger: AegisDied
//--------------------------------------------------------------------------------------------------
bool lib58D4CA39_gt_AegisDied_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Conditions
    if (testConds) {
        if (!((UnitGetType(EventUnit()) == "AegisShielded"))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    libNtve_gf_CatalogFieldValueSetAsReal(c_gameCatalogAbil, "KeironCitadelAegisTrainHero", "InfoArray[" + IntToString(0) + "].Cooldown.TimeUse", EventPlayer(), 300.0);
    return true;
}

//--------------------------------------------------------------------------------------------------
void lib58D4CA39_gt_AegisDied_Init () {
    lib58D4CA39_gt_AegisDied = TriggerCreate("lib58D4CA39_gt_AegisDied_Func");
    TriggerEnable(lib58D4CA39_gt_AegisDied, false);
    TriggerAddEventUnitDied(lib58D4CA39_gt_AegisDied, null);
}

//--------------------------------------------------------------------------------------------------
// Trigger: AegisCreated
//--------------------------------------------------------------------------------------------------
bool lib58D4CA39_gt_AegisCreated_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Conditions
    if (testConds) {
        if (!((UnitGetType(EventUnitCreatedUnit()) == "AegisShielded"))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    libNtve_gf_CatalogFieldValueSetAsReal(c_gameCatalogAbil, "KeironCitadelAegisTrainHero", "InfoArray[" + IntToString(0) + "].Cooldown.TimeUse", UnitGetOwner(EventUnitCreatedUnit()), 0.0);
    return true;
}

//--------------------------------------------------------------------------------------------------
void lib58D4CA39_gt_AegisCreated_Init () {
    lib58D4CA39_gt_AegisCreated = TriggerCreate("lib58D4CA39_gt_AegisCreated_Func");
    TriggerEnable(lib58D4CA39_gt_AegisCreated, false);
    TriggerAddEventUnitCreated(lib58D4CA39_gt_AegisCreated, null, null, null);
}

void lib58D4CA39_InitTriggers () {
    lib58D4CA39_gt_Initialization_Init();
    lib58D4CA39_gt_InitializeKeironRace_Init();
    lib58D4CA39_gt_KeironUpgrades_Init();
    lib58D4CA39_gt_KeironAutoAperture_Init();
    lib58D4CA39_gt_AegisDied_Init();
    lib58D4CA39_gt_AegisCreated_Init();
}

//--------------------------------------------------------------------------------------------------
// Library Initialization
//--------------------------------------------------------------------------------------------------
bool lib58D4CA39_InitLib_completed = false;

void lib58D4CA39_InitLib () {
    if (lib58D4CA39_InitLib_completed) {
        return;
    }

    lib58D4CA39_InitLib_completed = true;

    lib58D4CA39_InitLibraries();
    lib58D4CA39_InitTriggers();
}

